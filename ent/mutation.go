// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/andrewmthomas87/catan/ent/harbor"
	"github.com/andrewmthomas87/catan/ent/hex"
	"github.com/andrewmthomas87/catan/ent/numbertoken"
	"github.com/andrewmthomas87/catan/ent/player"
	"github.com/andrewmthomas87/catan/ent/predicate"
	"github.com/andrewmthomas87/catan/ent/road"
	"github.com/andrewmthomas87/catan/ent/robber"
	"github.com/andrewmthomas87/catan/ent/settlement"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeHarbor      = "Harbor"
	TypeHex         = "Hex"
	TypeNumberToken = "NumberToken"
	TypePlayer      = "Player"
	TypeRoad        = "Road"
	TypeRobber      = "Robber"
	TypeSettlement  = "Settlement"
)

// HarborMutation represents an operation that mutates the Harbor nodes in the graph.
type HarborMutation struct {
	config
	op                Op
	typ               string
	id                *int
	x                 *int
	addx              *int
	y                 *int
	addy              *int
	resource          *harbor.Resource
	clearedFields     map[string]struct{}
	settlement        *int
	clearedsettlement bool
	done              bool
	oldValue          func(context.Context) (*Harbor, error)
	predicates        []predicate.Harbor
}

var _ ent.Mutation = (*HarborMutation)(nil)

// harborOption allows management of the mutation configuration using functional options.
type harborOption func(*HarborMutation)

// newHarborMutation creates new mutation for the Harbor entity.
func newHarborMutation(c config, op Op, opts ...harborOption) *HarborMutation {
	m := &HarborMutation{
		config:        c,
		op:            op,
		typ:           TypeHarbor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHarborID sets the ID field of the mutation.
func withHarborID(id int) harborOption {
	return func(m *HarborMutation) {
		var (
			err   error
			once  sync.Once
			value *Harbor
		)
		m.oldValue = func(ctx context.Context) (*Harbor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Harbor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHarbor sets the old Harbor of the mutation.
func withHarbor(node *Harbor) harborOption {
	return func(m *HarborMutation) {
		m.oldValue = func(context.Context) (*Harbor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HarborMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HarborMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *HarborMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetX sets the "x" field.
func (m *HarborMutation) SetX(i int) {
	m.x = &i
	m.addx = nil
}

// X returns the value of the "x" field in the mutation.
func (m *HarborMutation) X() (r int, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old "x" field's value of the Harbor entity.
// If the Harbor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HarborMutation) OldX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// AddX adds i to the "x" field.
func (m *HarborMutation) AddX(i int) {
	if m.addx != nil {
		*m.addx += i
	} else {
		m.addx = &i
	}
}

// AddedX returns the value that was added to the "x" field in this mutation.
func (m *HarborMutation) AddedX() (r int, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX resets all changes to the "x" field.
func (m *HarborMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the "y" field.
func (m *HarborMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *HarborMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the Harbor entity.
// If the Harbor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HarborMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to the "y" field.
func (m *HarborMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *HarborMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY resets all changes to the "y" field.
func (m *HarborMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetResource sets the "resource" field.
func (m *HarborMutation) SetResource(h harbor.Resource) {
	m.resource = &h
}

// Resource returns the value of the "resource" field in the mutation.
func (m *HarborMutation) Resource() (r harbor.Resource, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the Harbor entity.
// If the Harbor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HarborMutation) OldResource(ctx context.Context) (v harbor.Resource, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ResetResource resets all changes to the "resource" field.
func (m *HarborMutation) ResetResource() {
	m.resource = nil
}

// SetSettlementID sets the "settlement" edge to the Settlement entity by id.
func (m *HarborMutation) SetSettlementID(id int) {
	m.settlement = &id
}

// ClearSettlement clears the "settlement" edge to the Settlement entity.
func (m *HarborMutation) ClearSettlement() {
	m.clearedsettlement = true
}

// SettlementCleared returns if the "settlement" edge to the Settlement entity was cleared.
func (m *HarborMutation) SettlementCleared() bool {
	return m.clearedsettlement
}

// SettlementID returns the "settlement" edge ID in the mutation.
func (m *HarborMutation) SettlementID() (id int, exists bool) {
	if m.settlement != nil {
		return *m.settlement, true
	}
	return
}

// SettlementIDs returns the "settlement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettlementID instead. It exists only for internal usage by the builders.
func (m *HarborMutation) SettlementIDs() (ids []int) {
	if id := m.settlement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettlement resets all changes to the "settlement" edge.
func (m *HarborMutation) ResetSettlement() {
	m.settlement = nil
	m.clearedsettlement = false
}

// Op returns the operation name.
func (m *HarborMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Harbor).
func (m *HarborMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HarborMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.x != nil {
		fields = append(fields, harbor.FieldX)
	}
	if m.y != nil {
		fields = append(fields, harbor.FieldY)
	}
	if m.resource != nil {
		fields = append(fields, harbor.FieldResource)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HarborMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case harbor.FieldX:
		return m.X()
	case harbor.FieldY:
		return m.Y()
	case harbor.FieldResource:
		return m.Resource()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HarborMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case harbor.FieldX:
		return m.OldX(ctx)
	case harbor.FieldY:
		return m.OldY(ctx)
	case harbor.FieldResource:
		return m.OldResource(ctx)
	}
	return nil, fmt.Errorf("unknown Harbor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HarborMutation) SetField(name string, value ent.Value) error {
	switch name {
	case harbor.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case harbor.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case harbor.FieldResource:
		v, ok := value.(harbor.Resource)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	}
	return fmt.Errorf("unknown Harbor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HarborMutation) AddedFields() []string {
	var fields []string
	if m.addx != nil {
		fields = append(fields, harbor.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, harbor.FieldY)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HarborMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case harbor.FieldX:
		return m.AddedX()
	case harbor.FieldY:
		return m.AddedY()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HarborMutation) AddField(name string, value ent.Value) error {
	switch name {
	case harbor.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case harbor.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	}
	return fmt.Errorf("unknown Harbor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HarborMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HarborMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HarborMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Harbor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HarborMutation) ResetField(name string) error {
	switch name {
	case harbor.FieldX:
		m.ResetX()
		return nil
	case harbor.FieldY:
		m.ResetY()
		return nil
	case harbor.FieldResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown Harbor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HarborMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.settlement != nil {
		edges = append(edges, harbor.EdgeSettlement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HarborMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case harbor.EdgeSettlement:
		if id := m.settlement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HarborMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HarborMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HarborMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsettlement {
		edges = append(edges, harbor.EdgeSettlement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HarborMutation) EdgeCleared(name string) bool {
	switch name {
	case harbor.EdgeSettlement:
		return m.clearedsettlement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HarborMutation) ClearEdge(name string) error {
	switch name {
	case harbor.EdgeSettlement:
		m.ClearSettlement()
		return nil
	}
	return fmt.Errorf("unknown Harbor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HarborMutation) ResetEdge(name string) error {
	switch name {
	case harbor.EdgeSettlement:
		m.ResetSettlement()
		return nil
	}
	return fmt.Errorf("unknown Harbor edge %s", name)
}

// HexMutation represents an operation that mutates the Hex nodes in the graph.
type HexMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	x                   *int
	addx                *int
	y                   *int
	addy                *int
	terrain             *hex.Terrain
	clearedFields       map[string]struct{}
	number_token        *int
	clearednumber_token bool
	robber              *int
	clearedrobber       bool
	settlements         map[int]struct{}
	removedsettlements  map[int]struct{}
	clearedsettlements  bool
	done                bool
	oldValue            func(context.Context) (*Hex, error)
	predicates          []predicate.Hex
}

var _ ent.Mutation = (*HexMutation)(nil)

// hexOption allows management of the mutation configuration using functional options.
type hexOption func(*HexMutation)

// newHexMutation creates new mutation for the Hex entity.
func newHexMutation(c config, op Op, opts ...hexOption) *HexMutation {
	m := &HexMutation{
		config:        c,
		op:            op,
		typ:           TypeHex,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHexID sets the ID field of the mutation.
func withHexID(id int) hexOption {
	return func(m *HexMutation) {
		var (
			err   error
			once  sync.Once
			value *Hex
		)
		m.oldValue = func(ctx context.Context) (*Hex, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hex.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHex sets the old Hex of the mutation.
func withHex(node *Hex) hexOption {
	return func(m *HexMutation) {
		m.oldValue = func(context.Context) (*Hex, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HexMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HexMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *HexMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetX sets the "x" field.
func (m *HexMutation) SetX(i int) {
	m.x = &i
	m.addx = nil
}

// X returns the value of the "x" field in the mutation.
func (m *HexMutation) X() (r int, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old "x" field's value of the Hex entity.
// If the Hex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HexMutation) OldX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// AddX adds i to the "x" field.
func (m *HexMutation) AddX(i int) {
	if m.addx != nil {
		*m.addx += i
	} else {
		m.addx = &i
	}
}

// AddedX returns the value that was added to the "x" field in this mutation.
func (m *HexMutation) AddedX() (r int, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX resets all changes to the "x" field.
func (m *HexMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the "y" field.
func (m *HexMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *HexMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the Hex entity.
// If the Hex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HexMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to the "y" field.
func (m *HexMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *HexMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY resets all changes to the "y" field.
func (m *HexMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetTerrain sets the "terrain" field.
func (m *HexMutation) SetTerrain(h hex.Terrain) {
	m.terrain = &h
}

// Terrain returns the value of the "terrain" field in the mutation.
func (m *HexMutation) Terrain() (r hex.Terrain, exists bool) {
	v := m.terrain
	if v == nil {
		return
	}
	return *v, true
}

// OldTerrain returns the old "terrain" field's value of the Hex entity.
// If the Hex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HexMutation) OldTerrain(ctx context.Context) (v hex.Terrain, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTerrain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTerrain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerrain: %w", err)
	}
	return oldValue.Terrain, nil
}

// ResetTerrain resets all changes to the "terrain" field.
func (m *HexMutation) ResetTerrain() {
	m.terrain = nil
}

// SetNumberTokenID sets the "number_token" edge to the NumberToken entity by id.
func (m *HexMutation) SetNumberTokenID(id int) {
	m.number_token = &id
}

// ClearNumberToken clears the "number_token" edge to the NumberToken entity.
func (m *HexMutation) ClearNumberToken() {
	m.clearednumber_token = true
}

// NumberTokenCleared returns if the "number_token" edge to the NumberToken entity was cleared.
func (m *HexMutation) NumberTokenCleared() bool {
	return m.clearednumber_token
}

// NumberTokenID returns the "number_token" edge ID in the mutation.
func (m *HexMutation) NumberTokenID() (id int, exists bool) {
	if m.number_token != nil {
		return *m.number_token, true
	}
	return
}

// NumberTokenIDs returns the "number_token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NumberTokenID instead. It exists only for internal usage by the builders.
func (m *HexMutation) NumberTokenIDs() (ids []int) {
	if id := m.number_token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNumberToken resets all changes to the "number_token" edge.
func (m *HexMutation) ResetNumberToken() {
	m.number_token = nil
	m.clearednumber_token = false
}

// SetRobberID sets the "robber" edge to the Robber entity by id.
func (m *HexMutation) SetRobberID(id int) {
	m.robber = &id
}

// ClearRobber clears the "robber" edge to the Robber entity.
func (m *HexMutation) ClearRobber() {
	m.clearedrobber = true
}

// RobberCleared returns if the "robber" edge to the Robber entity was cleared.
func (m *HexMutation) RobberCleared() bool {
	return m.clearedrobber
}

// RobberID returns the "robber" edge ID in the mutation.
func (m *HexMutation) RobberID() (id int, exists bool) {
	if m.robber != nil {
		return *m.robber, true
	}
	return
}

// RobberIDs returns the "robber" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RobberID instead. It exists only for internal usage by the builders.
func (m *HexMutation) RobberIDs() (ids []int) {
	if id := m.robber; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRobber resets all changes to the "robber" edge.
func (m *HexMutation) ResetRobber() {
	m.robber = nil
	m.clearedrobber = false
}

// AddSettlementIDs adds the "settlements" edge to the Settlement entity by ids.
func (m *HexMutation) AddSettlementIDs(ids ...int) {
	if m.settlements == nil {
		m.settlements = make(map[int]struct{})
	}
	for i := range ids {
		m.settlements[ids[i]] = struct{}{}
	}
}

// ClearSettlements clears the "settlements" edge to the Settlement entity.
func (m *HexMutation) ClearSettlements() {
	m.clearedsettlements = true
}

// SettlementsCleared returns if the "settlements" edge to the Settlement entity was cleared.
func (m *HexMutation) SettlementsCleared() bool {
	return m.clearedsettlements
}

// RemoveSettlementIDs removes the "settlements" edge to the Settlement entity by IDs.
func (m *HexMutation) RemoveSettlementIDs(ids ...int) {
	if m.removedsettlements == nil {
		m.removedsettlements = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsettlements[ids[i]] = struct{}{}
	}
}

// RemovedSettlements returns the removed IDs of the "settlements" edge to the Settlement entity.
func (m *HexMutation) RemovedSettlementsIDs() (ids []int) {
	for id := range m.removedsettlements {
		ids = append(ids, id)
	}
	return
}

// SettlementsIDs returns the "settlements" edge IDs in the mutation.
func (m *HexMutation) SettlementsIDs() (ids []int) {
	for id := range m.settlements {
		ids = append(ids, id)
	}
	return
}

// ResetSettlements resets all changes to the "settlements" edge.
func (m *HexMutation) ResetSettlements() {
	m.settlements = nil
	m.clearedsettlements = false
	m.removedsettlements = nil
}

// Op returns the operation name.
func (m *HexMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Hex).
func (m *HexMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HexMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.x != nil {
		fields = append(fields, hex.FieldX)
	}
	if m.y != nil {
		fields = append(fields, hex.FieldY)
	}
	if m.terrain != nil {
		fields = append(fields, hex.FieldTerrain)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HexMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hex.FieldX:
		return m.X()
	case hex.FieldY:
		return m.Y()
	case hex.FieldTerrain:
		return m.Terrain()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HexMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hex.FieldX:
		return m.OldX(ctx)
	case hex.FieldY:
		return m.OldY(ctx)
	case hex.FieldTerrain:
		return m.OldTerrain(ctx)
	}
	return nil, fmt.Errorf("unknown Hex field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HexMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hex.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case hex.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case hex.FieldTerrain:
		v, ok := value.(hex.Terrain)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerrain(v)
		return nil
	}
	return fmt.Errorf("unknown Hex field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HexMutation) AddedFields() []string {
	var fields []string
	if m.addx != nil {
		fields = append(fields, hex.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, hex.FieldY)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HexMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hex.FieldX:
		return m.AddedX()
	case hex.FieldY:
		return m.AddedY()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HexMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hex.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case hex.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	}
	return fmt.Errorf("unknown Hex numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HexMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HexMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HexMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hex nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HexMutation) ResetField(name string) error {
	switch name {
	case hex.FieldX:
		m.ResetX()
		return nil
	case hex.FieldY:
		m.ResetY()
		return nil
	case hex.FieldTerrain:
		m.ResetTerrain()
		return nil
	}
	return fmt.Errorf("unknown Hex field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HexMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.number_token != nil {
		edges = append(edges, hex.EdgeNumberToken)
	}
	if m.robber != nil {
		edges = append(edges, hex.EdgeRobber)
	}
	if m.settlements != nil {
		edges = append(edges, hex.EdgeSettlements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HexMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hex.EdgeNumberToken:
		if id := m.number_token; id != nil {
			return []ent.Value{*id}
		}
	case hex.EdgeRobber:
		if id := m.robber; id != nil {
			return []ent.Value{*id}
		}
	case hex.EdgeSettlements:
		ids := make([]ent.Value, 0, len(m.settlements))
		for id := range m.settlements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HexMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsettlements != nil {
		edges = append(edges, hex.EdgeSettlements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HexMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hex.EdgeSettlements:
		ids := make([]ent.Value, 0, len(m.removedsettlements))
		for id := range m.removedsettlements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HexMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearednumber_token {
		edges = append(edges, hex.EdgeNumberToken)
	}
	if m.clearedrobber {
		edges = append(edges, hex.EdgeRobber)
	}
	if m.clearedsettlements {
		edges = append(edges, hex.EdgeSettlements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HexMutation) EdgeCleared(name string) bool {
	switch name {
	case hex.EdgeNumberToken:
		return m.clearednumber_token
	case hex.EdgeRobber:
		return m.clearedrobber
	case hex.EdgeSettlements:
		return m.clearedsettlements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HexMutation) ClearEdge(name string) error {
	switch name {
	case hex.EdgeNumberToken:
		m.ClearNumberToken()
		return nil
	case hex.EdgeRobber:
		m.ClearRobber()
		return nil
	}
	return fmt.Errorf("unknown Hex unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HexMutation) ResetEdge(name string) error {
	switch name {
	case hex.EdgeNumberToken:
		m.ResetNumberToken()
		return nil
	case hex.EdgeRobber:
		m.ResetRobber()
		return nil
	case hex.EdgeSettlements:
		m.ResetSettlements()
		return nil
	}
	return fmt.Errorf("unknown Hex edge %s", name)
}

// NumberTokenMutation represents an operation that mutates the NumberToken nodes in the graph.
type NumberTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	value         *int
	addvalue      *int
	clearedFields map[string]struct{}
	hex           *int
	clearedhex    bool
	done          bool
	oldValue      func(context.Context) (*NumberToken, error)
	predicates    []predicate.NumberToken
}

var _ ent.Mutation = (*NumberTokenMutation)(nil)

// numbertokenOption allows management of the mutation configuration using functional options.
type numbertokenOption func(*NumberTokenMutation)

// newNumberTokenMutation creates new mutation for the NumberToken entity.
func newNumberTokenMutation(c config, op Op, opts ...numbertokenOption) *NumberTokenMutation {
	m := &NumberTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeNumberToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNumberTokenID sets the ID field of the mutation.
func withNumberTokenID(id int) numbertokenOption {
	return func(m *NumberTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *NumberToken
		)
		m.oldValue = func(ctx context.Context) (*NumberToken, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NumberToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNumberToken sets the old NumberToken of the mutation.
func withNumberToken(node *NumberToken) numbertokenOption {
	return func(m *NumberTokenMutation) {
		m.oldValue = func(context.Context) (*NumberToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NumberTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NumberTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *NumberTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetValue sets the "value" field.
func (m *NumberTokenMutation) SetValue(i int) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *NumberTokenMutation) Value() (r int, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the NumberToken entity.
// If the NumberToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NumberTokenMutation) OldValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to the "value" field.
func (m *NumberTokenMutation) AddValue(i int) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *NumberTokenMutation) AddedValue() (r int, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *NumberTokenMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetHexID sets the "hex" edge to the Hex entity by id.
func (m *NumberTokenMutation) SetHexID(id int) {
	m.hex = &id
}

// ClearHex clears the "hex" edge to the Hex entity.
func (m *NumberTokenMutation) ClearHex() {
	m.clearedhex = true
}

// HexCleared returns if the "hex" edge to the Hex entity was cleared.
func (m *NumberTokenMutation) HexCleared() bool {
	return m.clearedhex
}

// HexID returns the "hex" edge ID in the mutation.
func (m *NumberTokenMutation) HexID() (id int, exists bool) {
	if m.hex != nil {
		return *m.hex, true
	}
	return
}

// HexIDs returns the "hex" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HexID instead. It exists only for internal usage by the builders.
func (m *NumberTokenMutation) HexIDs() (ids []int) {
	if id := m.hex; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHex resets all changes to the "hex" edge.
func (m *NumberTokenMutation) ResetHex() {
	m.hex = nil
	m.clearedhex = false
}

// Op returns the operation name.
func (m *NumberTokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NumberToken).
func (m *NumberTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NumberTokenMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.value != nil {
		fields = append(fields, numbertoken.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NumberTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case numbertoken.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NumberTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case numbertoken.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown NumberToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NumberTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case numbertoken.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown NumberToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NumberTokenMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, numbertoken.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NumberTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case numbertoken.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NumberTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case numbertoken.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown NumberToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NumberTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NumberTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NumberTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NumberToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NumberTokenMutation) ResetField(name string) error {
	switch name {
	case numbertoken.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown NumberToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NumberTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hex != nil {
		edges = append(edges, numbertoken.EdgeHex)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NumberTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case numbertoken.EdgeHex:
		if id := m.hex; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NumberTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NumberTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NumberTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhex {
		edges = append(edges, numbertoken.EdgeHex)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NumberTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case numbertoken.EdgeHex:
		return m.clearedhex
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NumberTokenMutation) ClearEdge(name string) error {
	switch name {
	case numbertoken.EdgeHex:
		m.ClearHex()
		return nil
	}
	return fmt.Errorf("unknown NumberToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NumberTokenMutation) ResetEdge(name string) error {
	switch name {
	case numbertoken.EdgeHex:
		m.ResetHex()
		return nil
	}
	return fmt.Errorf("unknown NumberToken edge %s", name)
}

// PlayerMutation represents an operation that mutates the Player nodes in the graph.
type PlayerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	color         *player.Color
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Player, error)
	predicates    []predicate.Player
}

var _ ent.Mutation = (*PlayerMutation)(nil)

// playerOption allows management of the mutation configuration using functional options.
type playerOption func(*PlayerMutation)

// newPlayerMutation creates new mutation for the Player entity.
func newPlayerMutation(c config, op Op, opts ...playerOption) *PlayerMutation {
	m := &PlayerMutation{
		config:        c,
		op:            op,
		typ:           TypePlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerID sets the ID field of the mutation.
func withPlayerID(id int) playerOption {
	return func(m *PlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *Player
		)
		m.oldValue = func(ctx context.Context) (*Player, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Player.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayer sets the old Player of the mutation.
func withPlayer(node *Player) playerOption {
	return func(m *PlayerMutation) {
		m.oldValue = func(context.Context) (*Player, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PlayerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *PlayerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlayerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlayerMutation) ResetName() {
	m.name = nil
}

// SetColor sets the "color" field.
func (m *PlayerMutation) SetColor(pl player.Color) {
	m.color = &pl
}

// Color returns the value of the "color" field in the mutation.
func (m *PlayerMutation) Color() (r player.Color, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldColor(ctx context.Context) (v player.Color, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *PlayerMutation) ResetColor() {
	m.color = nil
}

// Op returns the operation name.
func (m *PlayerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Player).
func (m *PlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, player.FieldName)
	}
	if m.color != nil {
		fields = append(fields, player.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case player.FieldName:
		return m.Name()
	case player.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case player.FieldName:
		return m.OldName(ctx)
	case player.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Player field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case player.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case player.FieldColor:
		v, ok := value.(player.Color)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Player numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Player nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerMutation) ResetField(name string) error {
	switch name {
	case player.FieldName:
		m.ResetName()
		return nil
	case player.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Player unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Player edge %s", name)
}

// RoadMutation represents an operation that mutates the Road nodes in the graph.
type RoadMutation struct {
	config
	op            Op
	typ           string
	id            *int
	x             *int
	addx          *int
	y             *int
	addy          *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Road, error)
	predicates    []predicate.Road
}

var _ ent.Mutation = (*RoadMutation)(nil)

// roadOption allows management of the mutation configuration using functional options.
type roadOption func(*RoadMutation)

// newRoadMutation creates new mutation for the Road entity.
func newRoadMutation(c config, op Op, opts ...roadOption) *RoadMutation {
	m := &RoadMutation{
		config:        c,
		op:            op,
		typ:           TypeRoad,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoadID sets the ID field of the mutation.
func withRoadID(id int) roadOption {
	return func(m *RoadMutation) {
		var (
			err   error
			once  sync.Once
			value *Road
		)
		m.oldValue = func(ctx context.Context) (*Road, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Road.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoad sets the old Road of the mutation.
func withRoad(node *Road) roadOption {
	return func(m *RoadMutation) {
		m.oldValue = func(context.Context) (*Road, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RoadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetX sets the "x" field.
func (m *RoadMutation) SetX(i int) {
	m.x = &i
	m.addx = nil
}

// X returns the value of the "x" field in the mutation.
func (m *RoadMutation) X() (r int, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old "x" field's value of the Road entity.
// If the Road object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoadMutation) OldX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// AddX adds i to the "x" field.
func (m *RoadMutation) AddX(i int) {
	if m.addx != nil {
		*m.addx += i
	} else {
		m.addx = &i
	}
}

// AddedX returns the value that was added to the "x" field in this mutation.
func (m *RoadMutation) AddedX() (r int, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX resets all changes to the "x" field.
func (m *RoadMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the "y" field.
func (m *RoadMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *RoadMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the Road entity.
// If the Road object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoadMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to the "y" field.
func (m *RoadMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *RoadMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY resets all changes to the "y" field.
func (m *RoadMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// Op returns the operation name.
func (m *RoadMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Road).
func (m *RoadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoadMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.x != nil {
		fields = append(fields, road.FieldX)
	}
	if m.y != nil {
		fields = append(fields, road.FieldY)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case road.FieldX:
		return m.X()
	case road.FieldY:
		return m.Y()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case road.FieldX:
		return m.OldX(ctx)
	case road.FieldY:
		return m.OldY(ctx)
	}
	return nil, fmt.Errorf("unknown Road field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case road.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case road.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	}
	return fmt.Errorf("unknown Road field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoadMutation) AddedFields() []string {
	var fields []string
	if m.addx != nil {
		fields = append(fields, road.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, road.FieldY)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case road.FieldX:
		return m.AddedX()
	case road.FieldY:
		return m.AddedY()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case road.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case road.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	}
	return fmt.Errorf("unknown Road numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Road nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoadMutation) ResetField(name string) error {
	switch name {
	case road.FieldX:
		m.ResetX()
		return nil
	case road.FieldY:
		m.ResetY()
		return nil
	}
	return fmt.Errorf("unknown Road field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoadMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoadMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoadMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoadMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Road unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoadMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Road edge %s", name)
}

// RobberMutation represents an operation that mutates the Robber nodes in the graph.
type RobberMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	hex           *int
	clearedhex    bool
	done          bool
	oldValue      func(context.Context) (*Robber, error)
	predicates    []predicate.Robber
}

var _ ent.Mutation = (*RobberMutation)(nil)

// robberOption allows management of the mutation configuration using functional options.
type robberOption func(*RobberMutation)

// newRobberMutation creates new mutation for the Robber entity.
func newRobberMutation(c config, op Op, opts ...robberOption) *RobberMutation {
	m := &RobberMutation{
		config:        c,
		op:            op,
		typ:           TypeRobber,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRobberID sets the ID field of the mutation.
func withRobberID(id int) robberOption {
	return func(m *RobberMutation) {
		var (
			err   error
			once  sync.Once
			value *Robber
		)
		m.oldValue = func(ctx context.Context) (*Robber, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Robber.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRobber sets the old Robber of the mutation.
func withRobber(node *Robber) robberOption {
	return func(m *RobberMutation) {
		m.oldValue = func(context.Context) (*Robber, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RobberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RobberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RobberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHexID sets the "hex" edge to the Hex entity by id.
func (m *RobberMutation) SetHexID(id int) {
	m.hex = &id
}

// ClearHex clears the "hex" edge to the Hex entity.
func (m *RobberMutation) ClearHex() {
	m.clearedhex = true
}

// HexCleared returns if the "hex" edge to the Hex entity was cleared.
func (m *RobberMutation) HexCleared() bool {
	return m.clearedhex
}

// HexID returns the "hex" edge ID in the mutation.
func (m *RobberMutation) HexID() (id int, exists bool) {
	if m.hex != nil {
		return *m.hex, true
	}
	return
}

// HexIDs returns the "hex" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HexID instead. It exists only for internal usage by the builders.
func (m *RobberMutation) HexIDs() (ids []int) {
	if id := m.hex; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHex resets all changes to the "hex" edge.
func (m *RobberMutation) ResetHex() {
	m.hex = nil
	m.clearedhex = false
}

// Op returns the operation name.
func (m *RobberMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Robber).
func (m *RobberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RobberMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RobberMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RobberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Robber field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RobberMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Robber field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RobberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RobberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RobberMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Robber numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RobberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RobberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RobberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Robber nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RobberMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Robber field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RobberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hex != nil {
		edges = append(edges, robber.EdgeHex)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RobberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case robber.EdgeHex:
		if id := m.hex; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RobberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RobberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RobberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhex {
		edges = append(edges, robber.EdgeHex)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RobberMutation) EdgeCleared(name string) bool {
	switch name {
	case robber.EdgeHex:
		return m.clearedhex
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RobberMutation) ClearEdge(name string) error {
	switch name {
	case robber.EdgeHex:
		m.ClearHex()
		return nil
	}
	return fmt.Errorf("unknown Robber unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RobberMutation) ResetEdge(name string) error {
	switch name {
	case robber.EdgeHex:
		m.ResetHex()
		return nil
	}
	return fmt.Errorf("unknown Robber edge %s", name)
}

// SettlementMutation represents an operation that mutates the Settlement nodes in the graph.
type SettlementMutation struct {
	config
	op            Op
	typ           string
	id            *int
	x             *int
	addx          *int
	y             *int
	addy          *int
	is_city       *bool
	clearedFields map[string]struct{}
	hexes         map[int]struct{}
	removedhexes  map[int]struct{}
	clearedhexes  bool
	harbor        *int
	clearedharbor bool
	done          bool
	oldValue      func(context.Context) (*Settlement, error)
	predicates    []predicate.Settlement
}

var _ ent.Mutation = (*SettlementMutation)(nil)

// settlementOption allows management of the mutation configuration using functional options.
type settlementOption func(*SettlementMutation)

// newSettlementMutation creates new mutation for the Settlement entity.
func newSettlementMutation(c config, op Op, opts ...settlementOption) *SettlementMutation {
	m := &SettlementMutation{
		config:        c,
		op:            op,
		typ:           TypeSettlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettlementID sets the ID field of the mutation.
func withSettlementID(id int) settlementOption {
	return func(m *SettlementMutation) {
		var (
			err   error
			once  sync.Once
			value *Settlement
		)
		m.oldValue = func(ctx context.Context) (*Settlement, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettlement sets the old Settlement of the mutation.
func withSettlement(node *Settlement) settlementOption {
	return func(m *SettlementMutation) {
		m.oldValue = func(context.Context) (*Settlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *SettlementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetX sets the "x" field.
func (m *SettlementMutation) SetX(i int) {
	m.x = &i
	m.addx = nil
}

// X returns the value of the "x" field in the mutation.
func (m *SettlementMutation) X() (r int, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old "x" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldX(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// AddX adds i to the "x" field.
func (m *SettlementMutation) AddX(i int) {
	if m.addx != nil {
		*m.addx += i
	} else {
		m.addx = &i
	}
}

// AddedX returns the value that was added to the "x" field in this mutation.
func (m *SettlementMutation) AddedX() (r int, exists bool) {
	v := m.addx
	if v == nil {
		return
	}
	return *v, true
}

// ResetX resets all changes to the "x" field.
func (m *SettlementMutation) ResetX() {
	m.x = nil
	m.addx = nil
}

// SetY sets the "y" field.
func (m *SettlementMutation) SetY(i int) {
	m.y = &i
	m.addy = nil
}

// Y returns the value of the "y" field in the mutation.
func (m *SettlementMutation) Y() (r int, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldY(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// AddY adds i to the "y" field.
func (m *SettlementMutation) AddY(i int) {
	if m.addy != nil {
		*m.addy += i
	} else {
		m.addy = &i
	}
}

// AddedY returns the value that was added to the "y" field in this mutation.
func (m *SettlementMutation) AddedY() (r int, exists bool) {
	v := m.addy
	if v == nil {
		return
	}
	return *v, true
}

// ResetY resets all changes to the "y" field.
func (m *SettlementMutation) ResetY() {
	m.y = nil
	m.addy = nil
}

// SetIsCity sets the "is_city" field.
func (m *SettlementMutation) SetIsCity(b bool) {
	m.is_city = &b
}

// IsCity returns the value of the "is_city" field in the mutation.
func (m *SettlementMutation) IsCity() (r bool, exists bool) {
	v := m.is_city
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCity returns the old "is_city" field's value of the Settlement entity.
// If the Settlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettlementMutation) OldIsCity(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCity: %w", err)
	}
	return oldValue.IsCity, nil
}

// ResetIsCity resets all changes to the "is_city" field.
func (m *SettlementMutation) ResetIsCity() {
	m.is_city = nil
}

// AddHexIDs adds the "hexes" edge to the Hex entity by ids.
func (m *SettlementMutation) AddHexIDs(ids ...int) {
	if m.hexes == nil {
		m.hexes = make(map[int]struct{})
	}
	for i := range ids {
		m.hexes[ids[i]] = struct{}{}
	}
}

// ClearHexes clears the "hexes" edge to the Hex entity.
func (m *SettlementMutation) ClearHexes() {
	m.clearedhexes = true
}

// HexesCleared returns if the "hexes" edge to the Hex entity was cleared.
func (m *SettlementMutation) HexesCleared() bool {
	return m.clearedhexes
}

// RemoveHexIDs removes the "hexes" edge to the Hex entity by IDs.
func (m *SettlementMutation) RemoveHexIDs(ids ...int) {
	if m.removedhexes == nil {
		m.removedhexes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhexes[ids[i]] = struct{}{}
	}
}

// RemovedHexes returns the removed IDs of the "hexes" edge to the Hex entity.
func (m *SettlementMutation) RemovedHexesIDs() (ids []int) {
	for id := range m.removedhexes {
		ids = append(ids, id)
	}
	return
}

// HexesIDs returns the "hexes" edge IDs in the mutation.
func (m *SettlementMutation) HexesIDs() (ids []int) {
	for id := range m.hexes {
		ids = append(ids, id)
	}
	return
}

// ResetHexes resets all changes to the "hexes" edge.
func (m *SettlementMutation) ResetHexes() {
	m.hexes = nil
	m.clearedhexes = false
	m.removedhexes = nil
}

// SetHarborID sets the "harbor" edge to the Harbor entity by id.
func (m *SettlementMutation) SetHarborID(id int) {
	m.harbor = &id
}

// ClearHarbor clears the "harbor" edge to the Harbor entity.
func (m *SettlementMutation) ClearHarbor() {
	m.clearedharbor = true
}

// HarborCleared returns if the "harbor" edge to the Harbor entity was cleared.
func (m *SettlementMutation) HarborCleared() bool {
	return m.clearedharbor
}

// HarborID returns the "harbor" edge ID in the mutation.
func (m *SettlementMutation) HarborID() (id int, exists bool) {
	if m.harbor != nil {
		return *m.harbor, true
	}
	return
}

// HarborIDs returns the "harbor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HarborID instead. It exists only for internal usage by the builders.
func (m *SettlementMutation) HarborIDs() (ids []int) {
	if id := m.harbor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHarbor resets all changes to the "harbor" edge.
func (m *SettlementMutation) ResetHarbor() {
	m.harbor = nil
	m.clearedharbor = false
}

// Op returns the operation name.
func (m *SettlementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Settlement).
func (m *SettlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettlementMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.x != nil {
		fields = append(fields, settlement.FieldX)
	}
	if m.y != nil {
		fields = append(fields, settlement.FieldY)
	}
	if m.is_city != nil {
		fields = append(fields, settlement.FieldIsCity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settlement.FieldX:
		return m.X()
	case settlement.FieldY:
		return m.Y()
	case settlement.FieldIsCity:
		return m.IsCity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settlement.FieldX:
		return m.OldX(ctx)
	case settlement.FieldY:
		return m.OldY(ctx)
	case settlement.FieldIsCity:
		return m.OldIsCity(ctx)
	}
	return nil, fmt.Errorf("unknown Settlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settlement.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case settlement.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case settlement.FieldIsCity:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCity(v)
		return nil
	}
	return fmt.Errorf("unknown Settlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettlementMutation) AddedFields() []string {
	var fields []string
	if m.addx != nil {
		fields = append(fields, settlement.FieldX)
	}
	if m.addy != nil {
		fields = append(fields, settlement.FieldY)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettlementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case settlement.FieldX:
		return m.AddedX()
	case settlement.FieldY:
		return m.AddedY()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case settlement.FieldX:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddX(v)
		return nil
	case settlement.FieldY:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddY(v)
		return nil
	}
	return fmt.Errorf("unknown Settlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettlementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettlementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Settlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettlementMutation) ResetField(name string) error {
	switch name {
	case settlement.FieldX:
		m.ResetX()
		return nil
	case settlement.FieldY:
		m.ResetY()
		return nil
	case settlement.FieldIsCity:
		m.ResetIsCity()
		return nil
	}
	return fmt.Errorf("unknown Settlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.hexes != nil {
		edges = append(edges, settlement.EdgeHexes)
	}
	if m.harbor != nil {
		edges = append(edges, settlement.EdgeHarbor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettlementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case settlement.EdgeHexes:
		ids := make([]ent.Value, 0, len(m.hexes))
		for id := range m.hexes {
			ids = append(ids, id)
		}
		return ids
	case settlement.EdgeHarbor:
		if id := m.harbor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhexes != nil {
		edges = append(edges, settlement.EdgeHexes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettlementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case settlement.EdgeHexes:
		ids := make([]ent.Value, 0, len(m.removedhexes))
		for id := range m.removedhexes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhexes {
		edges = append(edges, settlement.EdgeHexes)
	}
	if m.clearedharbor {
		edges = append(edges, settlement.EdgeHarbor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettlementMutation) EdgeCleared(name string) bool {
	switch name {
	case settlement.EdgeHexes:
		return m.clearedhexes
	case settlement.EdgeHarbor:
		return m.clearedharbor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettlementMutation) ClearEdge(name string) error {
	switch name {
	case settlement.EdgeHarbor:
		m.ClearHarbor()
		return nil
	}
	return fmt.Errorf("unknown Settlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettlementMutation) ResetEdge(name string) error {
	switch name {
	case settlement.EdgeHexes:
		m.ResetHexes()
		return nil
	case settlement.EdgeHarbor:
		m.ResetHarbor()
		return nil
	}
	return fmt.Errorf("unknown Settlement edge %s", name)
}
